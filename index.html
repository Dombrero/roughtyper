<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RoughType</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --debug-bg: #f0f0f0;
            --debug-border: #ccc;
            --debug-content-bg: white;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --debug-bg: #2d2d2d;
            --debug-border: #404040;
            --debug-content-bg: #333333;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .theme-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            margin-left: 240px; /* Platz für die Sidebar */
        }

        #debugContainer {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 1200px;
            background: var(--debug-bg);
            border-top: 2px solid var(--debug-border);
            padding: 10px;
            border-radius: 10px 10px 0 0;
        }

        #debugHeader {
            cursor: pointer;
            padding: 5px;
            background: var(--debug-bg);
            margin-bottom: 10px;
        }

        #debugContent {
            display: none; /* Initial versteckt */
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: var(--debug-content-bg);
            border: 1px solid var(--debug-border);
            border-radius: 5px;
        }

        #copyButton {
            float: right;
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #copyButton:hover {
            background: #45a049;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: var(--debug-bg);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 100px; /* Mehr Platz nach unten */
        }

        .game-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            align-items: start;
            width: 100%;
            min-height: 400px;
        }

        .game-scene {
            height: 400px;
            padding: 20px;
            background: var(--debug-content-bg);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--debug-border);
        }

        .combat-log {
            height: 400px;
            padding: 15px;
            background: var(--debug-content-bg);
            border: 2px solid var(--debug-border);
            border-radius: 5px;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
        }

        .combat-log-entry {
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeIn 0.3s ease-in;
        }

        .combat-log-entry.loot {
            background: rgba(76, 175, 80, 0.1);
            border-left: 3px solid #4CAF50;
        }

        .combat-log-entry.damage {
            background: rgba(244, 67, 54, 0.1);
            border-left: 3px solid #f44336;
        }

        .combat-log-entry.kill {
            background: rgba(33, 150, 243, 0.1);
            border-left: 3px solid #2196F3;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .game-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: var(--debug-content-bg);
            border-radius: 5px;
            position: sticky;
            top: 45px;
            z-index: 1;
            margin-bottom: 0;
        }

        .game-stats div {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            background: var(--debug-bg);
            border-radius: 5px;
            text-align: center;
            white-space: nowrap;
        }

        .player {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: #4CAF50;
            border-radius: 50%;
        }

        .enemy-entity {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #f44336;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.1s linear;
        }

        .enemy-word {
            position: absolute;
            top: -25px;
            width: max-content;
            font-size: 16px;
            background: var(--debug-bg);
            padding: 2px 8px;
            border-radius: 4px;
            white-space: nowrap;
        }

        .enemy-health {
            position: absolute;
            bottom: -20px;
            font-size: 12px;
            color: var(--text-color);
        }

        .input-container {
            position: relative;
            width: 80%;
            max-width: 1200px;
            margin: 20px auto;
            text-align: center;
            z-index: 1000;
        }

        .typing-area {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid var(--debug-border);
            border-radius: 5px;
            background: var(--debug-content-bg);
            color: var(--text-color);
            outline: 2px solid #4CAF50;
        }

        .target-word {
            font-size: 24px;
            margin: 20px 0;
            letter-spacing: 2px;
        }

        .correct {
            color: #4CAF50;
        }

        .incorrect {
            color: #f44336;
        }

        .enemy {
            font-size: 20px;
            margin-bottom: 15px;
        }

        .enemy-word .correct {
            color: #4CAF50;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        .enemy-word .incorrect {
            color: #f44336;
            text-shadow: 0 0 5px rgba(244, 67, 54, 0.5);
        }

        .menu-container {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            position: relative; /* Für die Positionierung des Tutorials */
        }

        /* Hauptmenü-Optionen */
        .menu-container > .menu-option {
            font-size: 20px;
            padding: 10px;
            border-radius: 5px;
            transition: all 0.3s;
            cursor: pointer;
            text-align: center;
            display: block; /* Statt flex für Hauptmenü-Optionen */
        }

        .menu-container > .menu-option:hover {
            background: var(--debug-bg);
            transform: translateX(5px);
        }

        .menu-container.hidden {
            display: none;
        }

        /* Inventar und Shop Optionen */
        .inventory-section .menu-option,
        .materials-section .menu-option {
            padding: 12px;
            margin: 8px 0;
            background: var(--debug-bg);
            border-radius: 5px;
            transition: all 0.3s;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .inventory-section .menu-option:hover,
        .materials-section .menu-option:hover {
            transform: translateX(5px);
            background: var(--debug-border);
        }

        .menu-hint {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 14px;
            color: var(--text-color);
            opacity: 0.8;
        }

        .enemy-entity.boss {
            width: 50px;
            height: 50px;
            background: #ff4081;
            box-shadow: 0 0 10px #ff4081;
        }
        
        .enemy-entity.boss .enemy-word {
            font-size: 20px;
            font-weight: bold;
            color: #ff4081;
        }

        /* Level 10 Boss Styles */
        .enemy-entity.level10boss {
            width: 80px;
            height: 80px;
            background: #9c27b0;
            box-shadow: 0 0 15px #9c27b0;
            border: 3px solid #e1bee7;
            animation: floatBoss 4s infinite ease-in-out;
            top: 50px !important;
        }

        @keyframes floatBoss {
            0% { transform: translateX(-100px); }
            50% { transform: translateX(100px); }
            100% { transform: translateX(-100px); }
        }

        .boss-health-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
            z-index: 10;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            width: 100%;
            transition: width 0.3s ease-out;
        }

        .boss-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .boss-projectile {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #9c27b0;
            border-radius: 50%;
            z-index: 5;
            box-shadow: 0 0 8px #9c27b0;
            pointer-events: none;
        }

        /* Virtuelle Tastatur Styles */
        .virtual-keyboard {
            margin-top: 20px;
            padding: 10px;
            background: var(--debug-bg);
            border-radius: 10px;
            width: 100%;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .key {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--debug-content-bg);
            border: 1px solid var(--debug-border);
            border-radius: 5px;
            font-size: 16px;
            cursor: default;
            color: var(--text-color);
            transition: all 0.1s ease;
        }

        .key.space {
            width: 200px;
        }

        .key.active {
            background: #4CAF50;
            color: white;
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            width: 100%;
            height: calc(100vh - 300px); /* Höhe anpassen, um Platz für andere Elemente zu lassen */
        }

        .inventory-section, .materials-section {
            background: var(--debug-content-bg);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--debug-border);
            overflow-y: auto;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .inventory-section .items-container,
        .materials-section .materials-container {
            overflow-y: auto;
            flex-grow: 1;
            padding: 10px 0;
        }

        .inventory-section h2, .materials-section h2 {
            position: sticky;
            top: 0;
            background: var(--debug-content-bg);
            padding: 10px 0;
            margin: 0;
            border-bottom: 2px solid var(--debug-border);
            z-index: 2;
        }

        .inventory-section .game-stats {
            position: sticky;
            top: 45px;
            background: var(--debug-content-bg);
            padding: 10px 0;
            margin: 10px 0;
            z-index: 1;
            border-bottom: 1px solid var(--debug-border);
        }

        .inventory-instructions {
            background: rgba(33, 150, 243, 0.1);
            border-left: 3px solid #2196F3;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 14px;
        }

        .inventory-instructions p {
            margin: 5px 0;
        }

        .item-name {
            font-weight: bold;
            font-size: 16px;
        }

        .item-action {
            color: #4CAF50;
            font-style: italic;
        }

        .item-effect {
            font-size: 14px;
            color: #888;
        }

        /* Scrollbar-Styling */
        .inventory-section::-webkit-scrollbar,
        .materials-section::-webkit-scrollbar {
            width: 8px;
        }

        .inventory-section::-webkit-scrollbar-track,
        .materials-section::-webkit-scrollbar-track {
            background: var(--debug-bg);
            border-radius: 4px;
        }

        .inventory-section::-webkit-scrollbar-thumb,
        .materials-section::-webkit-scrollbar-thumb {
            background: var(--debug-border);
            border-radius: 4px;
        }

        .inventory-section::-webkit-scrollbar-thumb:hover,
        .materials-section::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        @media (max-width: 768px) {
            .inventory-grid {
                grid-template-columns: 1fr;
            }
            
            .game-stats {
                flex-direction: column;
            }
            
            .game-stats div {
                width: 100%;
            }
        }

        .material-item {
            padding: 12px;
            margin: 8px 0;
            background: var(--debug-bg);
            border-radius: 5px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: transform 0.2s;
        }

        .material-item:hover {
            transform: translateX(5px);
            background: var(--debug-border);
        }

        /* Neuer Stats-Container Stil */
        .stats-sidebar {
            position: fixed;
            left: 20px;
            top: 100px;
            width: 200px;
            background: var(--debug-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            z-index: 100;
            border: 2px solid var(--debug-border);
            transition: all 0.3s ease;
        }

        .stats-sidebar h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--debug-border);
            padding-bottom: 8px;
            text-align: center;
        }

        .stats-sidebar .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px;
            background: var(--debug-content-bg);
            border-radius: 5px;
        }

        .stats-sidebar .stat-value {
            font-weight: bold;
        }

        /* Anpassung für den Hauptinhalt */
        @media (min-width: 1200px) {
            .container {
                margin-left: 240px; /* Platz für die Sidebar */
            }
        }

        @media (max-width: 1199px) {
            .stats-sidebar {
                position: static;
                width: 100%;
                max-width: 1200px;
                margin: 0 auto 20px auto;
            }
            
            .container {
                margin-left: auto;
            }
        }

        /* Neuer verbesserter Menü-Hinweis */
        .menu-hint-improved {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #ffffff;
            background-color: rgba(76, 175, 80, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            font-weight: bold;
            animation: pulse 2s infinite;
            border: 2px solid #ffffff;
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* Tutorial-Bereich im Hauptmenü */
        .tutorial-container {
            position: absolute;
            right: -320px;
            top: 0;
            width: 300px;
            background: var(--debug-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border: 2px solid var(--debug-border);
            max-height: 100%;
            overflow-y: auto;
        }

        .tutorial-container h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--debug-border);
            padding-bottom: 8px;
            text-align: center;
        }

        .tutorial-section {
            margin-bottom: 15px;
        }

        .tutorial-section h4 {
            margin: 10px 0 5px 0;
            color: #4CAF50;
        }

        .tutorial-section p {
            margin: 5px 0;
            font-size: 14px;
            line-height: 1.4;
        }

        .tutorial-section ul {
            margin: 5px 0;
            padding-left: 20px;
            font-size: 14px;
        }

        .tutorial-section li {
            margin-bottom: 5px;
        }

        .tutorial-key {
            display: inline-block;
            background: var(--debug-content-bg);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--debug-border);
            font-family: monospace;
            margin: 0 2px;
        }

        /* Anpassung für kleinere Bildschirme */
        @media (max-width: 1500px) {
            .tutorial-container {
                position: static;
                width: 100%;
                margin-top: 20px;
                max-width: 1200px;
            }
        }

        /* Neue Animationen für Schuss und Treffer */
        @keyframes hit {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background-color: #ff9800; }
            100% { transform: scale(1); }
        }

        .enemy-entity.hit {
            animation: hit 0.3s ease-out;
        }

        .projectile {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #4CAF50;
            border-radius: 50%;
            z-index: 5;
            box-shadow: 0 0 5px #4CAF50;
            pointer-events: none;
        }

        @keyframes projectileFade {
            0% { opacity: 1; }
            80% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        /* Level-Auswahl Styling */
        .level-selection {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
            margin: 20px 0;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .level-option {
            background-color: transparent;
            border: 1px solid #4CAF50;
            color: var(--text-color);
            padding: 10px;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: 18px;
            text-align: center;
        }
        
        .level-option:hover {
            background-color: rgba(76, 175, 80, 0.1);
            transform: translateY(-2px);
        }
        
        .level-option[data-level="10"] {
            border: 2px solid #ff9800;
            font-weight: bold;
            position: relative;
        }
        
        .level-option[data-level="10"]::after {
            content: "BOSS";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #ff9800;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .level-option[data-level="10"]:hover {
            background-color: rgba(255, 152, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="theme-switch">
        <span>☀️</span>
        <label class="switch">
            <input type="checkbox" id="themeToggle">
            <span class="slider"></span>
        </label>
        <span>🌙</span>
    </div>

    <!-- Neuer Stats-Container -->
    <div class="stats-sidebar" id="statsSidebar">
        <h3>Player Stats</h3>
        <div class="stat-item">
            <span>❤️ Health:</span>
            <span class="stat-value" id="sidebarHealth">1000/1000</span>
        </div>
        <div class="stat-item">
            <span>💰 Gold:</span>
            <span class="stat-value" id="sidebarGold">0</span>
        </div>
        <div class="stat-item">
            <span>🏆 Level:</span>
            <span class="stat-value" id="sidebarLevel">1 (0/10)</span>
        </div>
        <div class="stat-item" id="sidebarDefenseContainer" style="display: none;">
            <span>🛡️ Defense:</span>
            <span class="stat-value" id="sidebarDefense">0</span>
        </div>
        <div class="stat-item">
            <span>🎯 Score:</span>
            <span class="stat-value" id="sidebarScore">0</span>
        </div>
        <div class="stat-item">
            <span>📦 Inventory:</span>
            <span class="stat-value" id="sidebarInventory">0</span>
        </div>
        <div class="stat-item">
            <span>🧪 Materials:</span>
            <span class="stat-value" id="sidebarMaterials">0</span>
        </div>
    </div>

    <div class="container">
        <h1>RoughType</h1>
        
        <div class="menu-container" id="mainMenu">
            <div class="menu-option">enter dungeon</div>
            <div class="menu-option">select level</div>
            <div class="menu-option">practice mode</div>
            <div class="menu-option">inventory</div>
            <div class="menu-option">shop</div>
            <div class="menu-option">new game</div>
            
            <!-- Tutorial-Bereich -->
            <div class="tutorial-container">
                <h3>Game Guide</h3>
                
                <div class="tutorial-section">
                    <h4>Navigation</h4>
                    <p>Type the name of an option to select it:</p>
                    <ul>
                        <li><strong>enter dungeon</strong> - Start the game</li>
                        <li><strong>select level</strong> - Choose a level to start from</li>
                        <li><strong>practice mode</strong> - Practice typing without time pressure</li>
                        <li><strong>inventory</strong> - Manage your items</li>
                        <li><strong>shop</strong> - Buy potions and equipment</li>
                        <li><strong>new game</strong> - Start a new game</li>
                    </ul>
                    <p>Type <span class="tutorial-key">menu</span> at any time to return to the main menu.</p>
        </div>

                <div class="tutorial-section">
                    <h4>Gameplay</h4>
                    <p>RoughType is a typing game with RPG elements:</p>
                    <ul>
                        <li>Type the words above monsters to defeat them</li>
                        <li>Each letter causes damage</li>
                        <li>Wrong inputs cause damage to you</li>
                        <li>Collect gold and materials from defeated monsters</li>
                        <li>Defeat 4 monsters (levels 1-3) or 10 monsters (from level 4) to level up</li>
                        <li>Bosses appear after certain levels</li>
                    </ul>
            </div>

                <div class="tutorial-section">
                    <h4>Inventory & Shop</h4>
                    <p>Use your gold to buy items in the shop:</p>
                    <ul>
                        <li>Potions heal your health points</li>
                        <li>Shields increase your defense</li>
                    </ul>
                    <p>In the inventory:</p>
                    <ul>
                        <li>Type <span class="tutorial-key">drink small/medium/large</span> to use potions</li>
                        <li>Type <span class="tutorial-key">use shield</span> to equip a shield</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h4>Practice Mode</h4>
                    <p>In practice mode, you can practice typing without time pressure:</p>
                    <ul>
                        <li>Random words from the game are displayed</li>
                        <li>No health points or time limit</li>
                        <li>Perfect for learning monster names</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h4>Tips</h4>
                    <ul>
                        <li>Focus first on monsters that are almost at the bottom</li>
                        <li>Use potions when your health falls below 300</li>
                        <li>Shields reduce damage from typing errors</li>
                        <li>In practice mode, you can learn all monster names</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="game-container" id="gameContainer">
            <div class="menu-hint">Type "menu" to return to main menu</div>
            <div class="game-layout">
            <div class="game-scene" id="gameScene">
                <div class="player" id="player"></div>
                </div>
                <div class="combat-log" id="combatLog"></div>
            </div>
        </div>

        <div class="input-container">
            <input type="text" class="typing-area" id="typingInput" placeholder="Type here..." autocomplete="off">
            <div class="virtual-keyboard">
                <div class="keyboard-row">
                    <div class="key" data-key="q">Q</div>
                    <div class="key" data-key="w">W</div>
                    <div class="key" data-key="e">E</div>
                    <div class="key" data-key="r">R</div>
                    <div class="key" data-key="t">T</div>
                    <div class="key" data-key="y">Y</div>
                    <div class="key" data-key="u">U</div>
                    <div class="key" data-key="i">I</div>
                    <div class="key" data-key="o">O</div>
                    <div class="key" data-key="p">P</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="a">A</div>
                    <div class="key" data-key="s">S</div>
                    <div class="key" data-key="d">D</div>
                    <div class="key" data-key="f">F</div>
                    <div class="key" data-key="g">G</div>
                    <div class="key" data-key="h">H</div>
                    <div class="key" data-key="j">J</div>
                    <div class="key" data-key="k">K</div>
                    <div class="key" data-key="l">L</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="z">Z</div>
                    <div class="key" data-key="x">X</div>
                    <div class="key" data-key="c">C</div>
                    <div class="key" data-key="v">V</div>
                    <div class="key" data-key="b">B</div>
                    <div class="key" data-key="n">N</div>
                    <div class="key" data-key="m">M</div>
                </div>
                <div class="keyboard-row">
                    <div class="key space" data-key=" ">Space</div>
                </div>
            </div>
        </div>
    </div>

    <div id="debugContainer">
        <div id="debugHeader">
            Debug Window ▼
            <button id="copyButton">Copy Log</button>
        </div>
        <div id="debugContent">
            Debug information appears here...
        </div>
    </div>

    <script>
        // Dark Mode Funktionalität
        const themeToggle = document.getElementById('themeToggle');
        
        // Gespeicherten Theme-Status laden
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
            themeToggle.checked = true;
        }

        themeToggle.addEventListener('change', function() {
            if (this.checked) {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
            }
        });

        const debugHeader = document.getElementById('debugHeader');
        const debugContent = document.getElementById('debugContent');
        const copyButton = document.getElementById('copyButton');

        // Debug-Fenster ein-/ausklappen
        debugHeader.addEventListener('click', function(e) {
            if (e.target !== copyButton) {
                debugContent.style.display = debugContent.style.display === 'none' ? 'block' : 'none';
                debugHeader.innerHTML = `Debug Window ${debugContent.style.display === 'none' ? '▲' : '▼'}
                    <button id="copyButton">Copy Log</button>`;
            }
        });

        // Log kopieren Funktionalität
        copyButton.addEventListener('click', function() {
            const text = debugContent.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Log copied to clipboard!');
            }).catch(err => {
                console.error('Error copying:', err);
            });
        });

        // DOM-Elemente initialisieren
        const mainMenu = document.getElementById('mainMenu');
        const gameContainer = document.getElementById('gameContainer');
        const typingInput = document.getElementById('typingInput');
        // Entfernt: const playerHealthDisplay = document.getElementById('playerHealth');
        // Entfernt: const scoreDisplay = document.getElementById('score');

        // Spielzustand
        const gameState = {
            playerHealth: 1000,
            score: 0,
            enemies: [],
            gameLoop: null,
            playerPosition: { x: 400, y: 380 },
            spawnTimer: 0,
            lastUpdate: 0,
            currentScreen: 'menu',
            inventory: [],
            gold: 100,
            defense: 0,
            level: 1,
            maxLevel: 1,
            monstersKilled: 0,
            bossActive: false,
            materials: [], // Neues Array für Materialien
            level10BossActive: false, // Neuer Status für Level 10 Boss
        };

        // Liste möglicher Gegner nach Level mit Icons
        const enemyTypes = {
            1: [
                { name: 'I', health: 3, goldReward: 1, icon: '🔤' },
                { name: 'A', health: 3, goldReward: 1, icon: '🔤' },
                { name: 'O', health: 3, goldReward: 1, icon: '🔤' }
            ],
            2: [
                { name: 'Up', health: 4, goldReward: 1, icon: '⬆️' },
                { name: 'On', health: 4, goldReward: 1, icon: '⭕' },
                { name: 'At', health: 4, goldReward: 1, icon: '📍' },
                { name: 'In', health: 4, goldReward: 1, icon: '📥' },
                { name: 'To', health: 4, goldReward: 1, icon: '➡️' }
            ],
            3: [
                { name: 'Rat', health: 6, goldReward: 2, icon: '🐀' },
                { name: 'Cat', health: 6, goldReward: 2, icon: '🐱' },
                { name: 'Bat', health: 6, goldReward: 2, icon: '🦇' },
                { name: 'Ant', health: 6, goldReward: 2, icon: '🐜' },
                { name: 'Bug', health: 6, goldReward: 2, icon: '🐛' }
            ],
            4: [
                { name: 'Frog', health: 8, goldReward: 2, icon: '🐸' },
                { name: 'Toad', health: 8, goldReward: 2, icon: '🦎' },
                { name: 'Worm', health: 8, goldReward: 2, icon: '🪱' },
                { name: 'Fish', health: 8, goldReward: 2, icon: '🐟' },
                { name: 'Crab', health: 8, goldReward: 2, icon: '🦀' }
            ],
            5: [
                { name: 'Snake', health: 10, goldReward: 3, icon: '🐍' },
                { name: 'Ghost', health: 10, goldReward: 3, icon: '👻' },
                { name: 'Slime', health: 10, goldReward: 3, icon: '🫧' },
                { name: 'Witch', health: 10, goldReward: 3, icon: '🧙‍♀️' },
                { name: 'Demon', health: 10, goldReward: 3, icon: '👿' }
            ],
            6: [
                { name: 'Spider', health: 12, goldReward: 3, icon: '🕷️' },
                { name: 'Dragon', health: 12, goldReward: 3, icon: '🐲' },
                { name: 'Zombie', health: 12, goldReward: 3, icon: '🧟' },
                { name: 'Knight', health: 12, goldReward: 3, icon: '🛡️' },
                { name: 'Goblin', health: 12, goldReward: 3, icon: '👺' }
            ],
            7: [
                { name: 'Vampire', health: 14, goldReward: 4, icon: '🧛' },
                { name: 'Phantom', health: 14, goldReward: 4, icon: '👻' },
                { name: 'Warrior', health: 14, goldReward: 4, icon: '⚔️' },
                { name: 'Mermaid', health: 14, goldReward: 4, icon: '🧜‍♀️' },
                { name: 'Griffin', health: 14, goldReward: 4, icon: '🦅' }
            ],
            8: [
                { name: 'Skeleton', health: 16, goldReward: 4, icon: '💀' },
                { name: 'Werewolf', health: 16, goldReward: 4, icon: '🐺' },
                { name: 'Basilisk', health: 16, goldReward: 4, icon: '🐍' },
                { name: 'Scorpion', health: 16, goldReward: 4, icon: '🦂' },
                { name: 'Gargoyle', health: 16, goldReward: 4, icon: '🗿' }
            ],
            9: [
                { name: 'Hydralisk', health: 18, goldReward: 5, icon: '🐉' },
                { name: 'Behemoth', health: 18, goldReward: 5, icon: '🦕' },
                { name: 'Leviathan', health: 18, goldReward: 5, icon: '🐋' },
                { name: 'Hellspawn', health: 18, goldReward: 5, icon: '😈' },
                { name: 'Dreadlord', health: 18, goldReward: 5, icon: '👑' }
            ],
            10: [
                { name: 'Dragonlord', health: 20, goldReward: 5, icon: '🐲' },
                { name: 'Shadowking', health: 20, goldReward: 5, icon: '🌑' },
                { name: 'Deathblade', health: 20, goldReward: 5, icon: '⚔️' },
                { name: 'Soulreaper', health: 20, goldReward: 5, icon: '💀' },
                { name: 'Doomslayer', health: 20, goldReward: 5, icon: '🔥' }
            ]
        };

        // Boss-Definitionen
        const bosses = {
            10: {
                name: 'DRAGON',
                health: 20,
                goldReward: 20,
                special: 'split',
                splitWords: ['DRA', 'GON', 'FIRE']
            },
            20: {
                name: 'HYDRA',
                health: 30,
                goldReward: 40,
                special: 'regenerate',
                regenRate: 1
            }
        };

        // Level 10 Boss Definition
        const level10Boss = {
            name: 'TYPEREX',
            health: 10, // 10 Worte zum Besiegen
            goldReward: 100,
            maxProjectiles: 2, // Zwei Worte gleichzeitig
            wordPool: [
                'DOOM', 'RAGE', 'FURY', 'WRATH', 'CHAOS', 
                'DEATH', 'PAIN', 'FEAR', 'DARK', 'VOID',
                'FIRE', 'HELL', 'EVIL', 'HATE', 'FALL',
                'RUIN', 'FATE', 'GRIM', 'SOUL', 'MIND'
            ],
            activeWords: [],
            element: null,
            healthBarElement: null,
            direction: 1,
            position: { x: 100, y: 50 },
            lastSpawnTime: 0
        };

        // Shop-Items mit Icons aktualisieren
        const shopItems = [
            { 
                name: "small",
                cost: 50, 
                effect: () => {
                    gameState.inventory.push({name: "small", type: "potion"});
                    updateDisplay(); // Sofort aktualisieren
                    return 'Small health potion added to inventory!';
                }
            },
            {
                name: "medium",
                cost: 100, 
                effect: () => {
                    gameState.inventory.push({name: "medium", type: "potion"});
                    updateDisplay(); // Sofort aktualisieren
                    return 'Medium health potion added to inventory!';
                }
            },
            {
                name: "large",
                cost: 200,
                effect: () => {
                    gameState.inventory.push({name: "large", type: "potion"});
                    updateDisplay(); // Sofort aktualisieren
                    return 'Large health potion added to inventory!';
                }
            },
            {
                name: "shield",
                cost: 300,
                effect: () => {
                    const hasEquippedShield = gameState.inventory.some(item => 
                        item.name === "shield" && item.type === "equipment" && item.equipped
                    );
                    
                    if (!hasEquippedShield) {
                        const newShield = {name: "shield", type: "equipment", equipped: true};
                        gameState.inventory.push(newShield);
                        gameState.defense += 5; // Direkt Defense erhöhen
                        updateDisplay(); // Sofort aktualisieren
                        return 'Shield equipped! Defense increased by 5';
                    } else {
                        gameState.inventory.push({name: "shield", type: "equipment"});
                        updateDisplay(); // Sofort aktualisieren
                    return 'Shield added to inventory!';
                    }
                }
            }
        ];

        // Drop-Definitionen für Monster
        const monsterDrops = {
            // Level 1
            'I': { item: 'letter fragment', chance: 0.3 },
            'A': { item: 'letter fragment', chance: 0.3 },
            'O': { item: 'letter fragment', chance: 0.3 },
            
            // Level 2
            'Up': { item: 'magic dust', chance: 0.4 },
            'On': { item: 'magic dust', chance: 0.4 },
            'At': { item: 'magic dust', chance: 0.4 },
            'In': { item: 'magic dust', chance: 0.4 },
            'To': { item: 'magic dust', chance: 0.4 },
            
            // Level 3
            'Rat': { item: 'rat tail', chance: 0.5 },
            'Cat': { item: 'cat whisker', chance: 0.5 },
            'Bat': { item: 'bat wing', chance: 0.5 },
            'Ant': { item: 'ant mandible', chance: 0.4 },
            'Bug': { item: 'bug shell', chance: 0.4 },
            
            // Level 4
            'Frog': { item: 'frog leg', chance: 0.5 },
            'Toad': { item: 'toad wart', chance: 0.5 },
            'Worm': { item: 'worm silk', chance: 0.4 },
            'Fish': { item: 'fish scale', chance: 0.4 },
            'Crab': { item: 'crab claw', chance: 0.4 },
            
            // Level 5
            'Snake': { item: 'snake fang', chance: 0.4 },
            'Ghost': { item: 'ectoplasm', chance: 0.3 },
            'Slime': { item: 'slime essence', chance: 0.5 },
            'Witch': { item: 'magic essence', chance: 0.3 },
            'Demon': { item: 'demon horn', chance: 0.2 }
        };

        // Gegner-Klasse aktualisieren
        class Enemy {
            constructor(name, health, goldReward, icon, special = null) {
                this.name = name;
                this.health = health;
                this.maxHealth = health;
                this.goldReward = goldReward * gameState.level;
                this.word = name.toLowerCase();
                this.icon = icon;
                
                // Sichere Spawn-Zone berechnen
                const wordWidth = this.word.length * 10; // Geschätzte Breite pro Buchstabe
                const safeMargin = Math.max(wordWidth, 100); // Mindestens 100px oder Wortbreite
                this.x = Math.random() * (760 - 2 * safeMargin) + safeMargin; // Zentrierterer Spawn-Bereich
                this.y = -50;
                this.speed = 30;
                this.element = null;
                this.special = special;
                this.isBoss = special !== null;
                this.lastDamageTime = Date.now();
                this.regenCooldown = 0;
            }

            createDOMElement() {
                const div = document.createElement('div');
                div.className = 'enemy-entity' + (this.isBoss ? ' boss' : '');
                div.style.left = this.x + 'px';
                div.style.top = this.y + 'px';

                const word = document.createElement('div');
                word.className = 'enemy-word';
                word.innerHTML = `${this.icon} ${this.word}`;

                const health = document.createElement('div');
                health.className = 'enemy-health';
                health.textContent = `${this.health} HP`;

                div.appendChild(word);
                div.appendChild(health);
                return div;
            }

            update(deltaTime) {
                this.y += this.speed * (deltaTime / 1000);
                if(this.element) {
                    this.element.style.left = this.x + 'px';
                    this.element.style.top = this.y + 'px';
                }

                // Boss-Spezialfähigkeiten
                if (this.special === 'regenerate') {
                    this.regenCooldown -= deltaTime;
                    if (this.regenCooldown <= 0 && Date.now() - this.lastDamageTime > 3000) {
                        this.health = Math.min(this.maxHealth, this.health + 1);
                        this.regenCooldown = 1000; // 1 Sekunde Cooldown zwischen Regenerationen
                        if(this.element) {
                            this.element.querySelector('.enemy-health').textContent = `${this.health} HP`;
                        }
                    }
                }
            }

            takeDamage() {
                this.health--;
                this.lastDamageTime = Date.now();
                if(this.element) {
                    this.element.querySelector('.enemy-health').textContent = `${this.health} HP`;
                    
                    // Füge Trefferanimation hinzu
                    this.element.classList.add('hit');
                    setTimeout(() => {
                        if (this.element) {
                            this.element.classList.remove('hit');
                        }
                    }, 300);
                }

                // Boss-Spezialfähigkeiten bei Tod
                if (this.health <= 0 && this.special === 'split') {
                    // Maximal 3 Split-Gegner gleichzeitig
                    const maxSplits = Math.min(3, bosses[10].splitWords.length);
                    for (let i = 0; i < maxSplits; i++) {
                        const word = bosses[10].splitWords[i];
                        const splitEnemy = new Enemy(word, word.length, this.goldReward / maxSplits, this.icon);
                        const element = splitEnemy.createDOMElement();
                        document.getElementById('gameScene').appendChild(element);
                        splitEnemy.element = element;
                        gameState.enemies.push(splitEnemy);
                    }
                }

                return this.health <= 0;
            }

            dropLoot() {
                const drop = monsterDrops[this.name];
                if (drop && Math.random() < drop.chance) {
                    addMaterial(drop.item);
                    const message = `${this.name} dropped ${drop.item}!`;
                    debugLog(message);
                    addCombatLogEntry('loot', message);
                    return drop.item;
                }
                return null;
            }
        }

        // Spiel-Loop
        function gameLoop(timestamp) {
            if (!gameState.lastUpdate) gameState.lastUpdate = timestamp;
            const deltaTime = timestamp - gameState.lastUpdate;

            // Level 10 Boss-Logik
            if (gameState.level10BossActive) {
                // Boss-Bewegung
                if (level10Boss.element) {
                    // Boss-Animation wird durch CSS-Animation gesteuert
                    
                    // Spawn-Timer für Worte
                    if (timestamp - level10Boss.lastSpawnTime > 3000 && level10Boss.activeWords.length < level10Boss.maxProjectiles) {
                        spawnBossWord();
                        level10Boss.lastSpawnTime = timestamp;
                    }
                    
                    // Aktive Worte aktualisieren
                    for (let i = level10Boss.activeWords.length - 1; i >= 0; i--) {
                        const word = level10Boss.activeWords[i];
                        word.position.y += word.speed * (deltaTime / 1000);
                        word.element.style.top = `${word.position.y}px`;
                        
                        // Prüfen, ob das Wort den Spieler erreicht hat
                        if (word.position.y > gameState.playerPosition.y - 40) {
                            gameState.playerHealth -= 20;
                            word.element.remove();
                            level10Boss.activeWords.splice(i, 1);
                            
                            // Neues Wort spawnen
                            setTimeout(spawnBossWord, 500);
                            
                            if (gameState.playerHealth <= 0) {
                                gameOver();
                                return;
                            }
                            updateDisplay();
                        }
                    }
                }
            } else {
                // Normale Gegner-Logik
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    enemy.update(deltaTime);
                    
                    // Prüfen ob Gegner den Spieler erreicht hat
                    if (enemy.y > gameState.playerPosition.y - 40) {
                        gameState.playerHealth -= 10;
                        removeEnemy(i);
                        if (gameState.playerHealth <= 0) {
                            gameOver();
                            return;
                        }
                        updateDisplay();
                    }
                }

                // Neue Gegner spawnen
                gameState.spawnTimer += deltaTime;
                if (gameState.spawnTimer > 3000 && gameState.enemies.length < 10) { // Maximal 10 Gegner gleichzeitig
                    spawnEnemy();
                    gameState.spawnTimer = 0;
                }
            }

            gameState.lastUpdate = timestamp;
            gameState.gameLoop = requestAnimationFrame(gameLoop);
        }

        // Gegner entfernen
        function removeEnemy(index) {
            if (gameState.enemies[index].element) {
                gameState.enemies[index].element.remove();
            }
            gameState.enemies.splice(index, 1);
        }

        // Spiel initialisieren (überarbeitet)
        function initGame() {
            loadGameState();
            if (gameState.playerHealth <= 0) {
                gameState.playerHealth = 1000;
            }
            gameState.score = 0;
            gameState.enemies = [];
            gameState.spawnTimer = 0;
            gameState.lastUpdate = 0;
            gameState.currentScreen = 'game';
            gameState.monstersKilled = 0;
            gameState.bossActive = false;
            gameState.level10BossActive = false; // Neuer Status für Level 10 Boss

            const gameScene = document.getElementById('gameScene');
            gameScene.innerHTML = `<div class="player" id="player"></div>`;

            if (gameState.gameLoop) {
                cancelAnimationFrame(gameState.gameLoop);
            }
            gameState.gameLoop = requestAnimationFrame(gameLoop);

            // Wenn Level 10 erreicht ist, starte den Level 10 Boss
            if (gameState.level === 10) {
                initLevel10Boss();
            } else {
                spawnEnemy();
            }
            
            updateDisplay();

            // Entferne alten Hinweis falls vorhanden
            const oldHint = document.querySelector('.menu-hint');
            if (oldHint) {
                oldHint.remove();
            }

            // Füge verbesserten Menü-Hinweis hinzu
            const hint = document.createElement('div');
            hint.className = 'menu-hint-improved';
            hint.innerHTML = '⌨️ Type <strong>"menu"</strong> to return to the main menu';
            
            // Hinweis nach 5 Sekunden ausblenden
            setTimeout(() => {
                hint.style.opacity = '0';
                hint.style.transition = 'opacity 1s ease-out';
                
                // Nach dem Ausblenden entfernen
                setTimeout(() => {
                    hint.remove();
                }, 1000);
            }, 5000);
            
            document.body.appendChild(hint);

            // Combat Log initialisieren
            const combatLog = document.getElementById('combatLog');
            if (combatLog) {
                addCombatLogEntry('info', `Welcome back! You start at Level ${gameState.level}!`);
                addCombatLogEntry('info', 'Type "menu" to return to the main menu.');
                
                // Spezielle Nachricht für Level 10 Boss
                if (gameState.level === 10) {
                    addCombatLogEntry('info', 'BOSS BATTLE! Defeat TYPEREX by typing all the words it throws at you!');
                }
            }
        }

        // Level 10 Boss initialisieren
        function initLevel10Boss() {
            gameState.level10BossActive = true;
            level10Boss.health = 10; // Reset boss health
            level10Boss.activeWords = []; // Reset active words
            level10Boss.lastSpawnTime = 0;
            
            // Boss-Element erstellen
            const gameScene = document.getElementById('gameScene');
            const bossElement = document.createElement('div');
            bossElement.className = 'enemy-entity level10boss';
            bossElement.style.left = '100px';
            bossElement.style.top = '50px';
            bossElement.innerHTML = `<div class="enemy-word">TYPEREX</div>`;
            gameScene.appendChild(bossElement);
            level10Boss.element = bossElement;
            
            // Boss Health Bar erstellen
            const healthBar = document.createElement('div');
            healthBar.className = 'boss-health-bar';
            healthBar.innerHTML = `
                <div class="boss-health-fill"></div>
                <div class="boss-health-text">TYPEREX: 10/10</div>
            `;
            gameScene.appendChild(healthBar);
            level10Boss.healthBarElement = healthBar;
            
            // Erste Worte spawnen
            spawnBossWord();
            
            addCombatLogEntry('info', 'TYPEREX has appeared! Type the falling words to defeat it!');
        }

        // Boss-Wort spawnen
        function spawnBossWord() {
            if (!gameState.level10BossActive || level10Boss.activeWords.length >= level10Boss.maxProjectiles) {
                return;
            }
            
            const gameScene = document.getElementById('gameScene');
            
            // Zufälliges Wort aus dem Pool auswählen
            const randomIndex = Math.floor(Math.random() * level10Boss.wordPool.length);
            const word = level10Boss.wordPool[randomIndex];
            
            // Projektil erstellen
            const projectile = document.createElement('div');
            projectile.className = 'boss-projectile';
            
            // Position unter dem Boss
            const bossRect = level10Boss.element.getBoundingClientRect();
            const gameSceneRect = gameScene.getBoundingClientRect();
            
            const startX = bossRect.left + bossRect.width / 2 - gameSceneRect.left;
            const startY = bossRect.top + bossRect.height - gameSceneRect.top;
            
            projectile.style.left = `${startX}px`;
            projectile.style.top = `${startY}px`;
            
            gameScene.appendChild(projectile);
            
            // Wort-Element erstellen
            const wordElement = document.createElement('div');
            wordElement.className = 'enemy-word';
            wordElement.textContent = word;
            wordElement.style.top = '-25px';
            projectile.appendChild(wordElement);
            
            // Wort zum aktiven Array hinzufügen
            level10Boss.activeWords.push({
                word: word.toLowerCase(),
                element: projectile,
                wordElement: wordElement,
                position: { x: startX, y: startY },
                speed: 40 + Math.random() * 20
            });
            
            // Nächstes Wort spawnen, wenn weniger als maxProjectiles aktiv sind
            if (level10Boss.activeWords.length < level10Boss.maxProjectiles) {
                setTimeout(spawnBossWord, 1000);
            }
        }

        // Boss-Wort entfernen
        function removeBossWord(index) {
            const word = level10Boss.activeWords[index];
            if (word.element) {
                word.element.remove();
            }
            level10Boss.activeWords.splice(index, 1);
            
            // Neues Wort spawnen
            setTimeout(spawnBossWord, 500);
            
            // Boss-Gesundheit aktualisieren
            level10Boss.health--;
            updateBossHealthBar();
            
            // Prüfen, ob der Boss besiegt wurde
            if (level10Boss.health <= 0) {
                defeatLevel10Boss();
            }
        }

        // Boss-Gesundheitsbalken aktualisieren
        function updateBossHealthBar() {
            if (!level10Boss.healthBarElement) return;
            
            const healthPercent = (level10Boss.health / 10) * 100;
            const healthFill = level10Boss.healthBarElement.querySelector('.boss-health-fill');
            const healthText = level10Boss.healthBarElement.querySelector('.boss-health-text');
            
            healthFill.style.width = `${healthPercent}%`;
            healthText.textContent = `TYPEREX: ${level10Boss.health}/10`;
        }

        // Level 10 Boss besiegen
        function defeatLevel10Boss() {
            gameState.level10BossActive = false;
            
            // Boss-Element entfernen
            if (level10Boss.element) {
                level10Boss.element.remove();
                level10Boss.element = null;
            }
            
            // Health Bar entfernen
            if (level10Boss.healthBarElement) {
                level10Boss.healthBarElement.remove();
                level10Boss.healthBarElement = null;
            }
            
            // Alle aktiven Worte entfernen
            level10Boss.activeWords.forEach(word => {
                if (word.element) {
                    word.element.remove();
                }
            });
            level10Boss.activeWords = [];
            
            // Belohnungen
            gameState.gold += level10Boss.goldReward;
            gameState.score += 100;
            
            // Level erhöhen
            gameState.level++;
            gameState.maxLevel = Math.max(gameState.level, gameState.maxLevel);
            gameState.monstersKilled = 0;
            
            // Benachrichtigungen
            addCombatLogEntry('kill', `You defeated TYPEREX! Earned ${level10Boss.goldReward} gold!`);
            alert(`Boss defeated! You are now Level ${gameState.level}!`);
            
            // Nächstes Level starten
            spawnEnemy();
            updateDisplay();
            saveGameState();
        }

        // Gegner spawnen aktualisieren
        function spawnEnemy() {
            // Wenn Level 10 erreicht ist und der Boss noch nicht aktiv ist, starte den Boss-Kampf
            if (gameState.level === 10 && !gameState.level10BossActive) {
                initLevel10Boss();
                return;
            }
            
            // Berechne die Anzahl der benötigten Monster für das aktuelle Level
            const monstersNeeded = gameState.level <= 3 ? 4 : 10;
            
            if (gameState.monstersKilled > 0 && gameState.monstersKilled % monstersNeeded === 0 && !gameState.bossActive) {
                // Berechne das Boss-Level basierend auf der Anzahl der getöteten Monster
                // Für die ersten 3 Level erscheint der Boss nach 4 Monstern, danach nach 10
                let bossLevel;
                if (gameState.level <= 3) {
                    bossLevel = Math.floor(gameState.level * 4 / 10) * 10;
                } else {
                    bossLevel = Math.floor(gameState.monstersKilled / 10) * 10;
                }
                
                if (bosses[bossLevel]) {
                    const boss = bosses[bossLevel];
                    gameState.bossActive = true;
                    const enemy = new Enemy(boss.name, boss.health, boss.goldReward, '👑', boss.special);
                    const element = enemy.createDOMElement();
                    document.getElementById('gameScene').appendChild(element);
                    enemy.element = element;
                    gameState.enemies.push(enemy);
                    return;
                }
            }

            const levelEnemies = enemyTypes[gameState.level];
            const randomEnemy = levelEnemies[Math.floor(Math.random() * levelEnemies.length)];
            const enemy = new Enemy(randomEnemy.name, randomEnemy.health, randomEnemy.goldReward, randomEnemy.icon);
            const element = enemy.createDOMElement();
            document.getElementById('gameScene').appendChild(element);
            enemy.element = element;
            gameState.enemies.push(enemy);
        }

        // Level-Up Funktion aktualisieren
        function levelUp() {
            gameState.level++;
            gameState.maxLevel = Math.max(gameState.level, gameState.maxLevel);
            gameState.monstersKilled = 0;
            gameState.bossActive = false;
            
            // Alle Gegner vom Spielfeld entfernen
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                removeEnemy(i);
            }
            
            // Benachrichtigung anzeigen
            alert(`Level Up! You are now Level ${gameState.level}!`);
            addCombatLogEntry('info', `You leveled up! Level ${gameState.level} reached!`);
            
            updateDisplay();
            saveGameState(); // Speichere nach Level-Up
        }

        // Display aktualisieren
        function updateDisplay() {
            // Berechne die Anzahl der benötigten Monster für das aktuelle Level
            const monstersNeeded = gameState.level <= 3 ? 4 : 10;
            
            // Sidebar Stats aktualisieren
            document.getElementById('sidebarHealth').textContent = `${gameState.playerHealth}/1000`;
            document.getElementById('sidebarGold').textContent = gameState.gold;
            document.getElementById('sidebarLevel').textContent = `${gameState.level} (${gameState.monstersKilled}/${monstersNeeded})`;
            document.getElementById('sidebarInventory').textContent = gameState.inventory.length;
            document.getElementById('sidebarMaterials').textContent = gameState.materials.reduce((total, mat) => total + mat.amount, 0);
            document.getElementById('sidebarScore').textContent = gameState.score;
            
            // Defense anzeigen wenn vorhanden
            if (gameState.defense > 0) {
                document.getElementById('sidebarDefenseContainer').style.display = 'flex';
                document.getElementById('sidebarDefense').textContent = gameState.defense;
            } else {
                document.getElementById('sidebarDefenseContainer').style.display = 'none';
            }
            
            // Speichern nach jeder Aktualisierung
            saveGameState();
        }

        // Debug-Hilfsfunktion
        function debugLog(message) {
            console.log(message);
            const debugContent = document.getElementById('debugContent');
            const timestamp = new Date().toLocaleTimeString();
            debugContent.innerHTML += `[${timestamp}] ${message}<br>`;
            debugContent.scrollTop = debugContent.scrollHeight;
        }

        // Funktion zum Aktualisieren der virtuellen Tastatur
        function refreshVirtualKeyboard() {
            const inputContainer = document.querySelector('.input-container');
            const oldKeyboard = inputContainer.querySelector('.virtual-keyboard');
            if (oldKeyboard) {
                oldKeyboard.remove();
            }

            const newKeyboard = document.createElement('div');
            newKeyboard.className = 'virtual-keyboard';
            newKeyboard.innerHTML = `
                <div class="keyboard-row">
                    <div class="key" data-key="q">Q</div>
                    <div class="key" data-key="w">W</div>
                    <div class="key" data-key="e">E</div>
                    <div class="key" data-key="r">R</div>
                    <div class="key" data-key="t">T</div>
                    <div class="key" data-key="y">Y</div>
                    <div class="key" data-key="u">U</div>
                    <div class="key" data-key="i">I</div>
                    <div class="key" data-key="o">O</div>
                    <div class="key" data-key="p">P</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="a">A</div>
                    <div class="key" data-key="s">S</div>
                    <div class="key" data-key="d">D</div>
                    <div class="key" data-key="f">F</div>
                    <div class="key" data-key="g">G</div>
                    <div class="key" data-key="h">H</div>
                    <div class="key" data-key="j">J</div>
                    <div class="key" data-key="k">K</div>
                    <div class="key" data-key="l">L</div>
                </div>
                <div class="keyboard-row">
                    <div class="key" data-key="z">Z</div>
                    <div class="key" data-key="x">X</div>
                    <div class="key" data-key="c">C</div>
                    <div class="key" data-key="v">V</div>
                    <div class="key" data-key="b">B</div>
                    <div class="key" data-key="n">N</div>
                    <div class="key" data-key="m">M</div>
                </div>
                <div class="keyboard-row">
                    <div class="key space" data-key=" ">Space</div>
                </div>
            `;
            inputContainer.appendChild(newKeyboard);
        }

        // Menü-Handling aktualisieren
        function handleMenuInput(typed) {
            debugLog(`handleMenuInput called with: "${typed}"`);
            typed = typed.toLowerCase();
            const menuOptions = ['enter dungeon', 'select level', 'practice mode', 'inventory', 'shop', 'menu', 'new game'];
            
            debugLog(`Current menu options: ${menuOptions.join(', ')}`);
            
            // Finde die erste Menüoption, die mit der Eingabe beginnt
            const matchingOption = menuOptions.find(option => option.startsWith(typed));
            debugLog(`Matching option found: ${matchingOption || 'none'}`);
            
            // Setze alle Menüoptionen zurück und markiere korrekte Buchstaben
            const menuElements = document.querySelectorAll('.menu-container > .menu-option');
            debugLog(`Found ${menuElements.length} menu elements`);
            
            menuElements.forEach(option => {
                const text = option.textContent.toLowerCase();
                debugLog(`Processing menu option: "${text}"`);
                
                // Prüfe, ob es sich um eine Hauptmenüoption handelt
                if (menuOptions.includes(text)) {
                    let html = '';
                    
                    // Prüfe, ob die Option mit der Eingabe beginnt
                    if (text.startsWith(typed)) {
                        for(let i = 0; i < text.length; i++) {
                            if (i < typed.length) {
                                html += `<span class="correct">${text[i]}</span>`;
                            } else {
                                html += text[i];
                            }
                        }
                    } else {
                        html = text; // Keine Übereinstimmung, zeige normalen Text
                    }
                    
                    debugLog(`Setting innerHTML for "${text}" to: ${html}`);
                    option.innerHTML = html;
                }
            });

            if (matchingOption && typed === matchingOption) {
                debugLog(`Complete match found: ${matchingOption}`);
                // Vollständiges Wort eingegeben
                switch(matchingOption) {
                    case 'enter dungeon':
                        gameState.currentScreen = 'game';
                        mainMenu.classList.add('hidden');
                        gameContainer.style.display = 'block';
                        initGame();
                        refreshVirtualKeyboard();
                        break;
                        
                    case 'select level':
                        gameState.currentScreen = 'selectLevel';
                        mainMenu.classList.add('hidden');
                        gameContainer.style.display = 'block';
                        initSelectLevel();
                        refreshVirtualKeyboard();
                        break;
                        
                    case 'practice mode':
                        gameState.currentScreen = 'practice';
                        mainMenu.classList.add('hidden');
                        gameContainer.style.display = 'block';
                        initPracticeMode();
                        refreshVirtualKeyboard();
                        break;
                        
                    case 'inventory':
                        gameState.currentScreen = 'inventory';
                        showInventory();
                        refreshVirtualKeyboard();
                        break;
                        
                    case 'shop':
                        gameState.currentScreen = 'shop';
                        showShop();
                        refreshVirtualKeyboard();
                        break;
                        
                    case 'menu':
                        if (gameState.currentScreen !== 'menu') {
                            returnToMenu();
                            refreshVirtualKeyboard();
                        }
                        break;

                    case 'new game':
                        if (confirm('Do you really want to start a new game? The current progress will be lost!')) {
                            resetGameState();
                            returnToMenu();
                            refreshVirtualKeyboard();
                            alert('New game started!');
                        }
                        break;
                }
                return true;
            }
            return false;
        }

        // Inventory-Handler aktualisieren
        function showInventory() {
            mainMenu.classList.add('hidden');
            gameContainer.style.display = 'block';
            
            const gameScene = document.getElementById('gameScene');
            gameScene.innerHTML = `
                <div class="menu-container">
                    <div class="inventory-grid">
                        <div class="inventory-section">
                            <h2>Inventory</h2>
                            <div class="inventory-instructions">
                                <p>Potions: Type "drink small/medium/large" to use</p>
                                <p>Equipment: Type "use shield" to equip</p>
                            </div>
                            <div class="items-container">
                                ${gameState.inventory.length === 0 ? 
                                    '<div>Empty inventory</div>' :
                                    gameState.inventory.map(item => {
                                        let itemDisplay = '';
                                        const status = item.equipped ? ' [Equipped]' : '';
                                        
                                        if (item.type === 'potion') {
                                            let healAmount = '?';
                                            if (item.name === 'small') healAmount = '30';
                                            else if (item.name === 'medium') healAmount = '60';
                                            else if (item.name === 'large') healAmount = '100';
                                            
                                            itemDisplay = `<div class="menu-option">
                                                <span class="item-name">${item.name} potion${status}</span>
                                                <span class="item-action">drink ${item.name}</span>
                                                <span class="item-effect">Heals ${healAmount} HP</span>
                                            </div>`;
                                        } else if (item.type === 'equipment') {
                                            itemDisplay = `<div class="menu-option">
                                                <span class="item-name">${item.name}${status}</span>
                                                ${!item.equipped ? `<span class="item-action">use ${item.name}</span>` : ''}
                                                <span class="item-effect">+5 Defense</span>
                                            </div>`;
                            } else {
                                            itemDisplay = `<div class="menu-option">${item.name}${status}</div>`;
                                        }
                                        
                                return itemDisplay;
                            }).join('')
                        }
                    </div>
                </div>
                <div class="materials-section">
                    <h2>Materials</h2>
                    <div class="materials-container">
                        ${gameState.materials.length === 0 ? 
                            '<div>No materials</div>' :
                            gameState.materials.map(material => 
                                `<div class="material-item">${material.name} x${material.amount}</div>`
                            ).join('')
                        }
                    </div>
                </div>
            </div>
            <div class="menu-option">menu</div>
        </div>
    `;
    
    updateDisplay();
}

function handleInventoryInput(input) {
    debugLog(`Processing inventory input: "${input}"`);
    
    // Definiere die möglichen Befehle
    const commands = {
        'drink small': () => {
            if (gameState.playerHealth >= 1000) {
                alert('You already have full health!');
                        return false;
                    }
            const smallPotion = gameState.inventory.findIndex(item => 
                item.name === 'small' && item.type === 'potion'
            );
            if (smallPotion !== -1) {
                gameState.playerHealth = Math.min(1000, gameState.playerHealth + 30);
                gameState.inventory.splice(smallPotion, 1);
                updateDisplay();
                addCombatLogEntry('info', 'You drank a small potion and healed 30 HP!');
                alert('30 HP healed!');
                showInventory();
                return true;
            }
            alert('No small health potion in inventory!');
            return false;
        },
        'drink medium': () => {
            if (gameState.playerHealth >= 1000) {
                alert('You already have full health!');
                return false;
            }
            const mediumPotion = gameState.inventory.findIndex(item => 
                item.name === 'medium' && item.type === 'potion'
            );
            if (mediumPotion !== -1) {
                gameState.playerHealth = Math.min(1000, gameState.playerHealth + 60);
                gameState.inventory.splice(mediumPotion, 1);
                updateDisplay();
                addCombatLogEntry('info', 'You drank a medium potion and healed 60 HP!');
                alert('60 HP healed!');
                showInventory();
                return true;
            }
            alert('No medium health potion in inventory!');
            return false;
        },
        'drink large': () => {
            if (gameState.playerHealth >= 1000) {
                alert('You already have full health!');
                return false;
            }
            const largePotion = gameState.inventory.findIndex(item => 
                item.name === 'large' && item.type === 'potion'
            );
            if (largePotion !== -1) {
                gameState.playerHealth = Math.min(1000, gameState.playerHealth + 100);
                gameState.inventory.splice(largePotion, 1);
                updateDisplay();
                addCombatLogEntry('info', 'You drank a large potion and healed 100 HP!');
                alert('100 HP healed!');
                showInventory();
                return true;
            }
            alert('No large health potion in inventory!');
            return false;
        },
        'use shield': () => {
                    const shield = gameState.inventory.find(item => 
                item.name === 'shield' && item.type === 'equipment' && !item.equipped
                    );
                    if (shield) {
                        shield.equipped = true;
                gameState.defense += 5; // Direkt Defense erhöhen
                        updateDisplay();
                addCombatLogEntry('info', 'You equipped a shield and increased your defense by 5!');
                alert('Shield equipped! Defense increased by 5');
                showInventory(); // Aktualisiere die Anzeige
                        return true;
                    }
            alert('No shield available to equip!');
                return false;
        },
        'menu': () => {
                    returnToMenu();
                    return true;
                }
    };

    // Finde den passenden Befehl
    const matchingCommand = Object.keys(commands).find(cmd => cmd.startsWith(input));
    
    // Markiere die passenden Befehle
    const menuOptions = document.querySelectorAll('.menu-option');
    menuOptions.forEach(option => {
        // Suche nach der item-action Klasse für Befehle
        const actionElement = option.querySelector('.item-action');
        if (actionElement) {
            const actionText = actionElement.textContent.toLowerCase();
            
            // Wenn der Befehl mit der Eingabe beginnt
            if (actionText.startsWith(input)) {
                // Hervorhebe den eingegebenen Teil
                actionElement.innerHTML = `<span class="correct">${input}</span>${actionText.slice(input.length)}`;
            } else {
                // Setze den Text zurück, wenn er nicht mehr passt
                actionElement.textContent = actionText;
            }
        } 
        // Prüfe auf die "menu" Option
        else if (option.textContent.toLowerCase() === 'menu' && 'menu'.startsWith(input)) {
            option.innerHTML = `<span class="correct">${input}</span>${'menu'.slice(input.length)}`;
        }
    });

    // Wenn ein vollständiger Befehl eingegeben wurde, führe ihn aus
    if (matchingCommand && input === matchingCommand) {
        debugLog(`Führe Befehl aus: ${matchingCommand}`);
        return commands[matchingCommand]();
            }

            return false;
        }

// Shop anzeigen aktualisieren
function showShop() {
            mainMenu.classList.add('hidden');
            gameContainer.style.display = 'block';
            
    const gameScene = document.getElementById('gameScene');
    gameScene.innerHTML = `
                <div class="menu-container">
            <h2>Shop</h2>
            ${shopItems.map(item => {
                let description = '';
                switch(item.name) {
                    case 'small':
                        description = 'Small Health Potion (Heals 30 HP)';
                        break;
                    case 'medium':
                        description = 'Medium Health Potion (Heals 60 HP)';
                        break;
                    case 'large':
                        description = 'Large Health Potion (Heals 100 HP)';
                        break;
                    case 'shield':
                        description = 'Shield (Adds 5 Defense)';
                        break;
                }
                return `<div class="menu-option">${description} - ${item.cost} gold</div>`;
            }).join('')}
                    <div class="menu-option">menu</div>
                </div>
            `;
            
    updateDisplay();
        }

// Shop-Input-Handler aktualisieren
        function handleShopInput(typed) {
            debugLog(`Processing shop input: "${typed}"`);
            
    // Markiere die Shop-Items entsprechend der Eingabe
    const menuOptions = document.querySelectorAll('.menu-option');
    menuOptions.forEach(option => {
        const text = option.textContent.toLowerCase();
        
        // Prüfe, ob es sich um ein Shop-Item handelt
        if (text.includes('-') && text.includes('gold')) {
            // Extrahiere den Item-Namen (alles vor dem ersten Leerzeichen)
            const itemName = text.split(' ')[0];
            
            // Finde das entsprechende Shop-Item
            const shopItem = shopItems.find(item => {
                switch(item.name) {
                    case 'small': return itemName === 'small';
                    case 'medium': return itemName === 'medium';
                    case 'large': return itemName === 'large';
                    case 'shield': return itemName === 'shield';
                    default: return false;
                }
            });
            
            // Wenn ein passendes Item gefunden wurde und es mit der Eingabe beginnt
            if (shopItem && shopItem.name.startsWith(typed)) {
                const words = option.textContent.split(' ');
                
                // Markiere nur den Item-Namen im ersten Wort
                if (words[0].toLowerCase().startsWith(typed)) {
                    const firstWord = words[0];
                    const highlighted = `<span class="correct">${typed}</span>${firstWord.slice(typed.length)}`;
                    words[0] = highlighted;
                    option.innerHTML = words.join(' ');
                }
            }
        } else if (text === 'menu' && 'menu'.startsWith(typed)) {
            // Hervorhebung für die "menu" Option
            option.innerHTML = `<span class="correct">${typed}</span>${text.slice(typed.length)}`;
        }
    });

    // Finde das passende Shop-Item
    const item = shopItems.find(item => item.name === typed);

    if (item) {
                if (gameState.gold >= item.cost) {
                    gameState.gold -= item.cost;
                    const message = item.effect();
                    debugLog(`Purchased ${item.name}: ${message}`);
            addCombatLogEntry('info', `You bought ${item.name} for ${item.cost} gold!`);
                    alert(`Purchased ${item.name}! ${message}`);
            saveGameState();
            showShop();
            updateDisplay();
                    return true;
                } else {
                    alert('Not enough gold!');
                    return false;
                }
    } else if (typed === 'menu') {
        returnToMenu();
        return true;
            }
            return false;
        }

        function returnToMenu() {
    if (gameState.currentScreen === 'game' && !confirm('Do you really want to return to the main menu? Your progress will be saved.')) {
        return;
    }
    saveGameState();
            gameState.currentScreen = 'menu';
            mainMenu.classList.remove('hidden');
            gameContainer.style.display = 'none';
            if (gameState.gameLoop) {
                cancelAnimationFrame(gameState.gameLoop);
            }
    // Setze Eingabefeld zurück
    document.getElementById('typingInput').value = '';
    
    // Aktualisiere die Sidebar
    updateDisplay();
        }

// Game Over Funktion aktualisieren
        function gameOver() {
    const goldEarned = Math.floor(gameState.score / 20);
    alert(`Game Over!\n\nScore: ${gameState.score}\nGold earned: ${goldEarned}\nLevel reached: ${gameState.level}\nMonsters killed: ${gameState.monstersKilled}`);
    gameState.gold += goldEarned;
    saveGameState();
            returnToMenu();
        }

// Input Validierung hinzufügen
function validateInput(input) {
    // Entferne unerwünschte Zeichen
    return input.replace(/[^a-zA-Z0-9\s]/g, '').toLowerCase();
        }

        // Input Handler aktualisieren
        document.getElementById('typingInput').addEventListener('input', function(e) {
    const typed = validateInput(e.target.value);
    if (typed !== e.target.value) {
        e.target.value = typed;
    }
    
            debugLog(`Input event fired. Value: "${typed}"`);
            debugLog(`Current screen: ${gameState.currentScreen}`);
            
            if (gameState.currentScreen === 'menu') {
                if (handleMenuInput(typed)) {
                    e.target.value = '';
                }
            } else if (gameState.currentScreen === 'shop') {
                if (handleShopInput(typed)) {
                    e.target.value = '';
                }
            } else if (gameState.currentScreen === 'inventory') {
                if (handleInventoryInput(typed)) {
                    e.target.value = '';
                }
            } else if (gameState.currentScreen === 'practice') {
                // Übungsmodus-Logik
                if ('menu'.startsWith(typed)) {
                    if (typed === 'menu') {
                        returnToMenu();
                        e.target.value = '';
                        return;
                    }
                    return;
                }
                
                // Überprüfe, ob das eingegebene Wort mit dem Übungswort übereinstimmt
                if (gameState.practiceWord.startsWith(typed)) {
                    // Markiere den korrekten Teil des Wortes
                    const practiceWordElement = document.querySelector('.practice-word');
                    let wordDisplay = '';
                    for(let i = 0; i < gameState.practiceWord.length; i++) {
                        if(i < typed.length) {
                            wordDisplay += `<span class="correct">${gameState.practiceWord[i]}</span>`;
                        } else {
                            wordDisplay += gameState.practiceWord[i];
                        }
                    }
                    practiceWordElement.innerHTML = wordDisplay;
                    
                    // Wenn das Wort vollständig ist
                    if (typed === gameState.practiceWord) {
                        updatePracticeScore();
                        generatePracticeWord();
                        e.target.value = '';
                    }
                } else if (typed.length > 0) {
                    // Falsche Eingabe - setze das Wort zurück
                    const practiceWordElement = document.querySelector('.practice-word');
                    practiceWordElement.textContent = gameState.practiceWord;
                    e.target.value = '';
                }
            } else if (gameState.currentScreen === 'game') {
                debugLog('Processing game input');
                
                // Prüfe ob die Eingabe mit "menu" beginnt
                if ('menu'.startsWith(typed)) {
                    debugLog('Potential menu command');
                    if (typed === 'menu') {
                        debugLog('Returning to menu from game');
                        returnToMenu();
                        e.target.value = '';
                        return;
                    }
                    return; // Keine weitere Verarbeitung wenn es ein potentielles Menü-Kommando ist
                }
                
                // Level 10 Boss-Logik
                if (gameState.level10BossActive) {
                    // Suche nach passenden Boss-Worten
                    const targetWordIndex = level10Boss.activeWords.findIndex(
                        word => word.word.startsWith(typed)
                    );
                    
                    if (targetWordIndex !== -1) {
                        const targetWord = level10Boss.activeWords[targetWordIndex];
                        
                        // Aktualisiere die Wortanzeige mit farbiger Markierung
                        let wordDisplay = '';
                        for(let i = 0; i < targetWord.word.length; i++) {
                            if(i < typed.length) {
                                wordDisplay += `<span class="correct">${targetWord.word[i]}</span>`;
                            } else {
                                wordDisplay += targetWord.word[i];
                            }
                        }
                        targetWord.wordElement.innerHTML = wordDisplay;
                        
                        // Wenn das Wort komplett ist
                        if (typed === targetWord.word) {
                            debugLog('Boss word defeated!');
                            gameState.score += targetWord.word.length;
                            
                            // Wort entfernen und Boss-Gesundheit reduzieren
                            removeBossWord(targetWordIndex);
                            e.target.value = '';
                            
                            // Kampflog-Eintrag
                            addCombatLogEntry('damage', `You typed "${targetWord.word}" and damaged TYPEREX!`);
                        }
                    } else if (typed.length > 0) {
                        // Falsche Eingabe - Schaden direkt mit Verteidigung reduzieren
                        const baseDamage = 10;
                        const damage = Math.max(1, baseDamage - gameState.defense);
                        gameState.playerHealth -= damage;
                        debugLog(`Taking ${damage} damage (Reduced by defense: ${gameState.defense})`);
                        e.target.value = '';
                        
                        // Setze alle Wortanzeigen zurück
                        level10Boss.activeWords.forEach(word => {
                            word.wordElement.textContent = word.word;
                        });
                        
                        if (gameState.playerHealth <= 0) {
                            gameOver();
                        }
                        updateDisplay();
                    }
                } else {
                    // Normale Gegner-Logik
                    const targetEnemyIndex = gameState.enemies.findIndex(
                        enemy => enemy.word.startsWith(typed)
                    );

                    if (targetEnemyIndex !== -1) {
                        const targetEnemy = gameState.enemies[targetEnemyIndex];
                        debugLog(`Found target enemy: ${targetEnemy.word}`);
                        
                        // Aktualisiere die Wortanzeige mit farbiger Markierung
                        const wordElement = targetEnemy.element.querySelector('.enemy-word');
                        let wordDisplay = '';
                        for(let i = 0; i < targetEnemy.word.length; i++) {
                            if(i < typed.length) {
                                wordDisplay += `<span class="correct">${targetEnemy.word[i]}</span>`;
                            } else {
                                wordDisplay += targetEnemy.word[i];
                            }
                        }
                        wordElement.innerHTML = wordDisplay;

                        // Wenn das Wort komplett ist
                        if (typed === targetEnemy.word) {
                            debugLog('Enemy defeated!');
                            gameState.score += targetEnemy.word.length;
                            if (targetEnemy.goldReward > 0) {
                                gameState.gold += targetEnemy.goldReward;
                                debugLog(`Earned ${targetEnemy.goldReward} gold!`);
                            }
                    
                            // Füge Materialien-Drop hinzu
                            const droppedItem = targetEnemy.dropLoot();
                            
                            // Level-Up Logik hinzufügen
                            if (!targetEnemy.isBoss) {
                                gameState.monstersKilled++;
                                // Für die ersten 3 Level nur 4 Monster benötigen
                                const monstersNeeded = gameState.level <= 3 ? 4 : 10;
                                if (gameState.monstersKilled >= monstersNeeded) {
                                    levelUp();
                                }
                            } else {
                                gameState.bossActive = false;
                            }
                            
                            removeEnemy(targetEnemyIndex);
                            e.target.value = '';
                        } else {
                            // Schussanimation für jeden korrekten Buchstaben
                            createProjectile(targetEnemy);
                            
                            // Wenn der Gegner durch den Schaden stirbt
                            const isDead = targetEnemy.health <= 1;
                            if (isDead) {
                                debugLog('Enemy killed by damage!');
                                gameState.score += targetEnemy.word.length;
                                if (targetEnemy.goldReward > 0) {
                                    gameState.gold += targetEnemy.goldReward;
                                    debugLog(`Earned ${targetEnemy.goldReward} gold!`);
                                }
                        
                                // Füge Materialien-Drop hinzu
                                const droppedItem = targetEnemy.dropLoot();
                                
                                // Level-Up Logik hinzufügen
                                if (!targetEnemy.isBoss) {
                                    gameState.monstersKilled++;
                                    // Für die ersten 3 Level nur 4 Monster benötigen
                                    const monstersNeeded = gameState.level <= 3 ? 4 : 10;
                                    if (gameState.monstersKilled >= monstersNeeded) {
                                        levelUp();
                                    }
                                } else {
                                    gameState.bossActive = false;
                                }
                                
                                // Kurze Verzögerung vor dem Entfernen des Gegners für bessere visuelle Wirkung
                                setTimeout(() => {
                                    removeEnemy(targetEnemyIndex);
                                    e.target.value = '';
                                }, 300);
                            }
                        }
                        updateDisplay();
                    } else if (typed.length > 0) {
                        debugLog('No matching enemy or command found, resetting input');
                        // Falsche Eingabe - Schaden direkt mit Verteidigung reduzieren
                        const baseDamage = 10; // Basis-Schaden bei Tippfehler
                        const damage = Math.max(1, baseDamage - gameState.defense); // Verteidigung reduziert den Schaden direkt, mindestens 1 Schaden
                        gameState.playerHealth -= damage;
                        debugLog(`Taking ${damage} damage (Reduced by defense: ${gameState.defense})`);
                        e.target.value = '';
                        
                        // Setze alle Wortanzeigen zurück
                        gameState.enemies.forEach(enemy => {
                            const wordElement = enemy.element.querySelector('.enemy-word');
                            wordElement.textContent = enemy.word;
                        });
                        
                        if (gameState.playerHealth <= 0) {
                            gameOver();
                        }
                        updateDisplay();
                    }
                }
            }
        });

        // Fokus-Handler verbessern
        function focusInput() {
            const input = document.getElementById('typingInput');
            input.focus();
            debugLog('Input field focused');
        }

        // Event Listener für Klicks
        document.addEventListener('click', focusInput);
        document.addEventListener('keydown', focusInput);

// Funktion zum Hinzufügen von Material
function addMaterial(material) {
    const existingMaterial = gameState.materials.find(m => m.name === material);
    if (existingMaterial) {
        existingMaterial.amount++;
    } else {
        gameState.materials.push({ name: material, amount: 1 });
    }
    updateDisplay(); // Sofort aktualisieren
    debugLog(`Added material: ${material}`);
}

// Funktion zum Speichern des Spielstands
function saveGameState() {
    const saveData = {
        gold: gameState.gold,
        level: gameState.level,
        maxLevel: gameState.maxLevel,
        defense: gameState.defense,
        inventory: gameState.inventory.map(item => ({
            ...item,
            element: null // DOM-Elemente nicht speichern
        })),
        playerHealth: gameState.playerHealth,
        monstersKilled: gameState.monstersKilled,
        score: gameState.score,
        materials: gameState.materials
    };
    try {
        localStorage.setItem('roughTypeGameState', JSON.stringify(saveData));
        debugLog('Spielstand erfolgreich gespeichert');
    } catch (error) {
        debugLog('Fehler beim Speichern des Spielstands: ' + error.message);
        alert('Fehler beim Speichern des Spielstands!');
    }
}

// Funktion zum Laden des Spielstands
function loadGameState() {
    try {
        // Prüfe, ob ein Reset-Flag gesetzt ist
        const resetDone = localStorage.getItem('roughTypeResetDone');
        
        if (!resetDone) {
            // Einmaliger Reset: Lösche vorhandenen Spielstand
            localStorage.removeItem('roughTypeGameState');
            
            // Setze Spielstand auf Standardwerte zurück
            gameState.gold = 100;
            gameState.level = 1;
            gameState.maxLevel = 1;
            gameState.defense = 0;
            gameState.inventory = [];
            gameState.playerHealth = 1000;
            gameState.monstersKilled = 0;
            gameState.score = 0;
            gameState.materials = [];
            
            // Setze das Reset-Flag, damit der Reset nicht wieder durchgeführt wird
            localStorage.setItem('roughTypeResetDone', 'true');
            
            debugLog('Neues Spiel gestartet (einmaliger Reset)');
        } else {
            // Normales Laden des Spielstands
            const savedData = localStorage.getItem('roughTypeGameState');
            if (savedData) {
                const data = JSON.parse(savedData);
                gameState.gold = data.gold || 100;
                gameState.level = data.level || 1;
                gameState.maxLevel = data.maxLevel || 1;
                gameState.defense = data.defense || 0;
                gameState.inventory = data.inventory || [];
                gameState.playerHealth = data.playerHealth || 1000;
                gameState.monstersKilled = data.monstersKilled || 0;
                gameState.score = data.score || 0;
                gameState.materials = data.materials || [];
                
                // Stelle ausgerüstete Items wieder her
                gameState.inventory.forEach(item => {
                    if (item.type === 'equipment' && item.equipped) {
                        if (item.name === 'shield') {
                            gameState.defense = Math.max(gameState.defense, 5);
                        }
                    }
                });
                
                debugLog('Spielstand erfolgreich geladen');
            } else {
                // Kein Spielstand vorhanden, starte neues Spiel
                gameState.gold = 100;
                gameState.level = 1;
                gameState.maxLevel = 1;
                gameState.defense = 0;
                gameState.inventory = [];
                gameState.playerHealth = 1000;
                gameState.monstersKilled = 0;
                gameState.score = 0;
                gameState.materials = [];
                
                debugLog('Neues Spiel gestartet (kein Spielstand vorhanden)');
            }
        }
        
        // Aktualisiere die Anzeige
        updateDisplay();
    } catch (error) {
        debugLog('Fehler beim Laden des Spielstands: ' + error.message);
        alert('Fehler beim Laden des Spielstands!');
        
        // Setze auf Standardwerte zurück bei Fehler
        gameState.gold = 100;
        gameState.level = 1;
        gameState.maxLevel = 1;
        gameState.defense = 0;
        gameState.inventory = [];
        gameState.playerHealth = 1000;
        gameState.monstersKilled = 0;
        gameState.score = 0;
        gameState.materials = [];
        
        updateDisplay();
    }
}

// Funktion zum Zurücksetzen des Spielstands
function resetGameState() {
    // Setze alle Werte auf Anfangszustand zurück
    gameState.playerHealth = 1000;
    gameState.score = 0;
    gameState.enemies = [];
    gameState.inventory = [];
    gameState.defense = 0;
    gameState.level = 1;
    gameState.maxLevel = 1;
    gameState.monstersKilled = 0;
    gameState.bossActive = false;
    gameState.materials = [];
    
    // Lösche gespeicherten Spielstand
    localStorage.removeItem('roughTypeGameState');
    debugLog('Spielstand zurückgesetzt');
    
    // Aktualisiere die Anzeige
    updateDisplay();
}

// Initialisierung aktualisieren
        window.addEventListener('load', function() {
            debugLog('Page loaded');
    loadGameState(); // Lade Spielstand beim Start
    updateDisplay(); // Aktualisiere die Sidebar
            focusInput();
            returnToMenu();
    refreshVirtualKeyboard(); // Initiale Tastatur anzeigen
    
    // Stelle sicher, dass die Sidebar immer sichtbar ist
    document.getElementById('statsSidebar').style.display = 'block';
});

// Tastatur-Highlight Funktionalität
document.addEventListener('keydown', function(e) {
    const key = e.key.toLowerCase();
    const keyElement = document.querySelector(`.key[data-key="${key}"]`);
    if (keyElement) {
        keyElement.classList.add('active');
    }
});

document.addEventListener('keyup', function(e) {
    const key = e.key.toLowerCase();
    const keyElement = document.querySelector(`.key[data-key="${key}"]`);
    if (keyElement) {
        keyElement.classList.remove('active');
    }
});

// Neue Funktion für Combat Log Einträge
function addCombatLogEntry(type, message) {
    const combatLog = document.getElementById('combatLog');
    if (!combatLog) return;

    const entry = document.createElement('div');
    entry.className = `combat-log-entry ${type}`;
    entry.textContent = message;
    
    combatLog.insertBefore(entry, combatLog.firstChild);
    
    // Begrenze die Anzahl der Einträge
    while (combatLog.children.length > 50) {
        combatLog.removeChild(combatLog.lastChild);
    }
}

// Neue Funktion für den Übungsmodus
function initPracticeMode() {
    gameState.currentScreen = 'practice';
    gameState.practiceWord = '';
    gameState.practiceScore = 0;
    
    // Setze die Spielszene zurück
    const gameScene = document.getElementById('gameScene');
    gameScene.innerHTML = `
        <div class="player" id="player" style="bottom: 200px;"></div>
        <div class="practice-dummy" style="position: absolute; top: 150px; left: 50%; transform: translateX(-50%); width: 60px; height: 60px; background: #888; border-radius: 50%; display: flex; justify-content: center; align-items: center;">
            <span style="font-size: 24px;">🎯</span>
        </div>
        <div class="practice-word" style="position: absolute; top: 100px; left: 50%; transform: translateX(-50%); font-size: 24px; background: var(--debug-bg); padding: 10px; border-radius: 5px;"></div>
        <div class="practice-score" style="position: absolute; top: 20px; left: 20px; font-size: 18px;">Score: 0</div>
    `;
    
    // Leere den Combat Log
    const combatLog = document.getElementById('combatLog');
    combatLog.innerHTML = '';
    
    // Füge eine Erklärung hinzu
    addCombatLogEntry('info', 'Practice Mode: Type the displayed words to practice. There is no time limit.');
    addCombatLogEntry('info', 'Type "menu" to return to the main menu.');
    
    // Generiere das erste Wort
    generatePracticeWord();
    
    // Entferne alten Hinweis falls vorhanden
    const oldHint = document.querySelector('.menu-hint');
    if (oldHint) {
        oldHint.remove();
    }

    // Füge verbesserten Menü-Hinweis hinzu
    const hint = document.createElement('div');
    hint.className = 'menu-hint-improved';
    hint.innerHTML = '⌨️ Type <strong>"menu"</strong> to return to the main menu';
    
    // Hinweis nach 5 Sekunden ausblenden
    setTimeout(() => {
        hint.style.opacity = '0';
        hint.style.transition = 'opacity 1s ease-out';
        
        // Nach dem Ausblenden entfernen
        setTimeout(() => {
            hint.remove();
        }, 1000);
    }, 5000);
    
    document.body.appendChild(hint);
}

// Funktion zum Generieren eines zufälligen Übungswortes
function generatePracticeWord() {
    // Sammle alle Monsterwörter aus allen Leveln
    let allMonsterWords = [];
    for (let level = 1; level <= 10; level++) {
        if (enemyTypes[level]) {
            enemyTypes[level].forEach(enemy => {
                allMonsterWords.push({
                    word: enemy.name.toLowerCase(),
                    icon: enemy.icon
                });
            });
        }
    }
    
    // Füge auch Boss-Wörter hinzu
    Object.values(bosses).forEach(boss => {
        allMonsterWords.push({
            word: boss.name.toLowerCase(),
            icon: '👑'
        });
        
        // Füge auch Split-Wörter hinzu, falls vorhanden
        if (boss.splitWords) {
            boss.splitWords.forEach(word => {
                allMonsterWords.push({
                    word: word.toLowerCase(),
                    icon: '🔥'
                });
            });
        }
    });
    
    // Wähle ein zufälliges Wort aus
    const randomMonster = allMonsterWords[Math.floor(Math.random() * allMonsterWords.length)];
    gameState.practiceWord = randomMonster.word;
    
    // Zeige das Wort an
    const practiceWordElement = document.querySelector('.practice-word');
    practiceWordElement.innerHTML = `${randomMonster.icon} ${randomMonster.word}`;
    
    debugLog(`Neues Übungswort generiert: ${randomMonster.word}`);
}

// Funktion zum Aktualisieren des Übungsmodus-Scores
function updatePracticeScore() {
    gameState.practiceScore++;
    const scoreElement = document.querySelector('.practice-score');
    scoreElement.textContent = `Score: ${gameState.practiceScore}`;
    
    // Füge einen Eintrag zum Combat Log hinzu
    addCombatLogEntry('kill', `You correctly typed "${gameState.practiceWord}"!`);
}

        // Neue Funktion zum Erstellen und Animieren eines Projektils
        function createProjectile(targetEnemy) {
            const gameScene = document.getElementById('gameScene');
            const player = document.getElementById('player');
            const projectile = document.createElement('div');
            projectile.className = 'projectile';
            
            // Startposition (Spieler)
            const playerRect = player.getBoundingClientRect();
            const gameSceneRect = gameScene.getBoundingClientRect();
            
            const startX = playerRect.left + playerRect.width / 2 - gameSceneRect.left;
            const startY = playerRect.top + playerRect.height / 2 - gameSceneRect.top;
            
            // Zielposition (Gegner)
            const enemyRect = targetEnemy.element.getBoundingClientRect();
            const targetX = enemyRect.left + enemyRect.width / 2 - gameSceneRect.left;
            const targetY = enemyRect.top + enemyRect.height / 2 - gameSceneRect.top;
            
            projectile.style.left = `${startX}px`;
            projectile.style.top = `${startY}px`;
            
            gameScene.appendChild(projectile);
            
            // Animation
            const duration = 200; // ms
            const startTime = performance.now();
            
            function animateProjectile(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const currentX = startX + (targetX - startX) * progress;
                const currentY = startY + (targetY - startY) * progress;
                
                projectile.style.left = `${currentX}px`;
                projectile.style.top = `${currentY}px`;
                
                if (progress < 1) {
                    requestAnimationFrame(animateProjectile);
                } else {
                    // Treffer-Animation auslösen
                    targetEnemy.takeDamage();
                    
                    // Projektil ausblenden und entfernen
                    projectile.style.animation = 'projectileFade 0.2s forwards';
                    setTimeout(() => {
                        if (projectile.parentNode) {
                            projectile.parentNode.removeChild(projectile);
                        }
                    }, 200);
                }
            }
            
            requestAnimationFrame(animateProjectile);
        }

        // Level-Auswahl initialisieren
        function initSelectLevel() {
            const gameScene = document.getElementById('gameScene');
            
            // Bestimme das maximale Level, das der Spieler auswählen kann
            // (kann nur bis zum höchsten erreichten Level oder maximal 10 auswählen)
            const maxSelectableLevel = Math.min(gameState.maxLevel, 10);
            
            // Erstelle das HTML für die Level-Auswahl
            let levelButtonsHTML = '';
            for (let i = 1; i <= maxSelectableLevel; i++) {
                const specialClass = i === 10 ? 'boss-level' : '';
                const bossLabel = i === 10 ? '<span class="boss-label">BOSS</span>' : '';
                levelButtonsHTML += `<button class="level-button ${specialClass}" data-level="${i}">Level ${i} ${bossLabel}</button>`;
            }
            
            // Erstelle das HTML für das Menü
            gameScene.innerHTML = `
                <div class="level-select-container">
                    <h2>Select Starting Level</h2>
                    <p>Choose a level to start from (up to your highest reached level):</p>
                    
                    <div class="level-buttons-grid">
                        ${levelButtonsHTML}
                    </div>
                    
                    <button class="back-button" id="backToMenuButton">Back to Menu</button>
                </div>
            `;
            
            // Füge CSS für das neue Menü hinzu
            const style = document.createElement('style');
            style.textContent = `
                .level-select-container {
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                    text-align: center;
                }
                
                .level-buttons-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                    gap: 15px;
                    margin: 30px 0;
                }
                
                .level-button {
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    padding: 15px 10px;
                    font-size: 18px;
                    border-radius: 5px;
                    cursor: pointer;
                    transition: all 0.3s;
                    position: relative;
                }
                
                .level-button:hover {
                    transform: translateY(-3px);
                    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                }
                
                .level-button.boss-level {
                    background-color: #ff9800;
                    font-weight: bold;
                }
                
                .boss-label {
                    position: absolute;
                    top: -10px;
                    right: -10px;
                    background-color: #f44336;
                    color: white;
                    font-size: 12px;
                    padding: 3px 6px;
                    border-radius: 10px;
                }
                
                .back-button {
                    background-color: #607d8b;
                    color: white;
                    border: none;
                    padding: 12px 25px;
                    font-size: 16px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin-top: 20px;
                    transition: all 0.3s;
                }
                
                .back-button:hover {
                    background-color: #455a64;
                }
            `;
            document.head.appendChild(style);
            
            // Event-Listener für Level-Buttons
            const levelButtons = document.querySelectorAll('.level-button');
            levelButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const level = parseInt(this.getAttribute('data-level'));
                    startGameAtLevel(level);
                });
            });
            
            // Event-Listener für den Zurück-Button
            document.getElementById('backToMenuButton').addEventListener('click', function() {
                returnToMenu();
            });
            
            // Leere das Eingabefeld, um Probleme zu vermeiden
            const inputField = document.getElementById('gameInput');
            if (inputField) {
                inputField.value = '';
            }
        }

        // Funktion zum Starten des Spiels mit einem ausgewählten Level
        function startGameAtLevel(level) {
            // Lade den Spielstand
            loadGameState();
            
            // Setze das Level und die entsprechenden Werte
            gameState.level = level;
            gameState.monstersKilled = 0;
            gameState.score = (level - 1) * 100; // Gib Punkte für vorherige Level
            gameState.gold = 100 + (level - 1) * 50; // Mehr Gold für höhere Level
            
            // Starte das Spiel
            gameState.currentScreen = 'game';
            gameState.enemies = [];
            gameState.spawnTimer = 0;
            gameState.lastUpdate = 0;
            gameState.bossActive = false;
            gameState.level10BossActive = false;
            
            const gameScene = document.getElementById('gameScene');
            gameScene.innerHTML = `<div class="player" id="player"></div>`;
            
            if (gameState.gameLoop) {
                cancelAnimationFrame(gameState.gameLoop);
            }
            
            // Zeige einen Hinweis an, dass das Spiel auf Level X gestartet wurde
            addCombatLog(`Starting game at Level ${level}!`);
            
            // Aktualisiere die Anzeige
            updateDisplay();
            
            // Starte das Spiel
            gameLoop();
            
            // Speichere den Spielstand
            saveGameState();
        }
    </script>
</body>
</html> 